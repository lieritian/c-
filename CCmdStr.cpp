#include "CCmdStr.h"// 安全的strcpy函数。// dest：目标字符串，不需要初始化，在STRCPY函数中有初始化代码。// destlen：目标字符串dest占用内存的大小。// src：原字符串。// 返回值：目标字符串dest的地址。char *STRCPY(char* dest,const size_t destlen,const char* src){  if (dest==0) return 0;  memset(dest,0,destlen);   // 初始化dest。  if (src==0) return dest;  if (strlen(src)>destlen-1) strncpy(dest,src,destlen-1);   else strcpy(dest,src);  return dest;}// 删除字符串左边指定的字符。// str：待处理的字符串。// chr：需要删除的字符。void DeleteLChar(char *str,const char chr){  if (str == 0) return;  if (strlen(str) == 0) return;  char strTemp[strlen(str)+1];  int iTemp=0;  memset(strTemp,0,sizeof(strTemp));  strcpy(strTemp,str);  while ( strTemp[iTemp] == chr )  iTemp++;  memset(str,0,strlen(str)+1);  strcpy(str,strTemp+iTemp);  return;}// 删除字符串右边指定的字符。// str：待处理的字符串。// chr：需要删除的字符。void DeleteRChar(char *str,const char chr){  if (str == 0) return;  if (strlen(str) == 0) return;  int istrlen = strlen(str);  while (istrlen>0)  {    if (str[istrlen-1] != chr) break;    str[istrlen-1]=0;    istrlen--;  }}// 删除字符串左右两边指定的字符。// str：待处理的字符串。// chr：需要删除的字符。void DeleteLRChar(char *str,const char chr){  DeleteLChar(str,chr);  DeleteRChar(str,chr);}// 把字符串中的小写字母转换成大写，忽略不是字母的字符。// str：待转换的字符串，支持char[]和string两种类型。void ToUpper(char *str){  if (str == 0) return;  if (strlen(str) == 0) return;  int istrlen=strlen(str);  for (int ii=0;ii<istrlen;ii++)  {    if ( (str[ii] >= 'a') && (str[ii] <= 'z') ) str[ii]=str[ii] - 32;  }}CCmdStr::CCmdStr(){  m_vCmdStr.clear();}// 把字符串拆分到m_vCmdStr容器中。// buffer：待拆分的字符串。// sepstr：buffer字符串中字段内容的分隔符，注意，分隔符是字符串，如","、" "、"|"、"~!~"。// bdelspace：是否删除拆分后的字段内容前后的空格，true-删除；false-不删除，缺省删除。void CCmdStr::SplitToCmd(const string buffer,const char *sepstr,const bool bdelspace){  // 清除所有的旧数据  m_vCmdStr.clear();  int iPOS=0;  string srcstr,substr;  srcstr=buffer;  char str[2048];  while ( (iPOS=srcstr.find(sepstr)) >= 0)  {    substr=srcstr.substr(0,iPOS);    if (bdelspace == true)    {      memset(str,0,sizeof(str));      strncpy(str,substr.c_str(),2000);      DeleteLRChar(str,' ');      substr=str;    }    m_vCmdStr.push_back(substr);    iPOS=iPOS+strlen(sepstr);    srcstr=srcstr.substr(iPOS,srcstr.size()-iPOS);  }  substr=srcstr;  if (bdelspace == true)  {    memset(str,0,sizeof(str));    strncpy(str,substr.c_str(),2000);    DeleteLRChar(str,' ');    substr=str;  }  m_vCmdStr.push_back(substr);  return;}int CCmdStr::CmdCount(){  return m_vCmdStr.size();}bool CCmdStr::GetValue(const int inum,char *value,const int ilen){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  if (ilen>0) memset(value,0,ilen+1);   // 调用者必须保证value的空间足够，否则这里会内存溢出。  if ( (m_vCmdStr[inum].length()<=(unsigned int)ilen) || (ilen==0) )  {    strcpy(value,m_vCmdStr[inum].c_str());  }  else  {    strncpy(value,m_vCmdStr[inum].c_str(),ilen); value[ilen]=0;  }  return true;}bool CCmdStr::GetValue(const int inum,int *value){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  (*value) = 0;  if (inum >= m_vCmdStr.size()) return false;  (*value) = atoi(m_vCmdStr[inum].c_str());  return true;}bool CCmdStr::GetValue(const int inum,unsigned int *value){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  (*value) = 0;  if (inum >= m_vCmdStr.size()) return false;  (*value) = atoi(m_vCmdStr[inum].c_str());  return true;}bool CCmdStr::GetValue(const int inum,long *value){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  (*value) = 0;  if (inum >= m_vCmdStr.size()) return false;  (*value) = atol(m_vCmdStr[inum].c_str());  return true;}bool CCmdStr::GetValue(const int inum,unsigned long *value){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  (*value) = 0;  if (inum >= m_vCmdStr.size()) return false;  (*value) = atol(m_vCmdStr[inum].c_str());  return true;}bool CCmdStr::GetValue(const int inum,double *value){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  (*value) = 0;  if (inum >= m_vCmdStr.size()) return false;  (*value) = (double)atof(m_vCmdStr[inum].c_str());  return true;}bool CCmdStr::GetValue(const int inum,bool *value){  if ( (inum>=m_vCmdStr.size()) || (value==0) ) return false;  (*value) = 0;  if (inum >= m_vCmdStr.size()) return false;  char strTemp[11];  memset(strTemp,0,sizeof(strTemp));  strncpy(strTemp,m_vCmdStr[inum].c_str(),10);  ToUpper(strTemp);  // 转换为大写来判断。  if (strcmp(strTemp,"TRUE")==0) (*value)=true;   return true;}CCmdStr::~CCmdStr(){  m_vCmdStr.clear();}